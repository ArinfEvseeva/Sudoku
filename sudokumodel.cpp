#include "sudokumodel.h"
#include <QMessageBox>
#include <QSize>
#include <algorithm>

SudokuModel::SudokuModel()
{
m_Game.Create(LevelsFactory::Create("4 x 4"));
}

int SudokuModel::rowCount(const QModelIndex &parent) const
{
    return  m_Game.GetLevel()->GetRowsCnt();
}

int SudokuModel::columnCount(const QModelIndex &parent) const
{
    return m_Game.GetLevel()->GetColumnsCnt();
}

QVariant SudokuModel::data(const QModelIndex &index, int role) const
{
//Qt::BackgroundColorRole
    if (Qt::TextAlignmentRole == role)
           return Qt::AlignCenter;

    if(!index.isValid())
         return QVariant();

    int nRow = index.row();
    int nCol = index.column();

   if (Qt::BackgroundColorRole == role &&
       m_Game.IsAutoGeneratedItem(nRow, nCol))
        return  QColor(188, 196, 230, 127);

    if(Qt::EditRole != role && Qt::DisplayRole !=role)
        return QVariant();



    QString resValue;
    if(!m_Game.GetItemValue(nRow, nCol,resValue))
        return QVariant();


    return resValue;
}

bool SudokuModel::setData(const QModelIndex &index, const QVariant &value, int role)
{

    if(!index.isValid() || role != Qt::EditRole)
        return false;

    int nRow = index.row();
    int nCol= index.column();

    if(m_Game.IsAutoGeneratedItem(nRow, nCol))
        return false;


    QString settingValue = value.toString();


    m_Game.SetItemValue(nRow, nCol, settingValue);


    emit dataChanged(index,index);

    return true;
}

int SudokuModel::GetDifficultValue() const{return m_Game.GetLevel()->GetDifficultValue();}


void SudokuModel::SetDifficult(const QString& strDifficultName)
{
    //от пункта меню
    try {
        m_Game.Create(LevelsFactory::Create(strDifficultName));
    } catch (const std::exception& ex) {
        QMessageBox::critical(nullptr,"Ошибка", "Ошибка установки уровня");
    }
}



std::unique_ptr<DifficultLvlBase> LevelsFactory::Create(const QString &strDifficultName)
{
    for(size_t nLvl = 0; nLvl < GetAvailableLevels().size(); ++nLvl)
    {
        //беру эталонный объект, из которого хочу создать копию
        const std::unique_ptr<DifficultLvlBase>& pCurrentTemplateObject = GetAvailableLevels().at(nLvl);
        if(pCurrentTemplateObject->GetName() == strDifficultName)
        {
             //изготавливаю из прототипа pCurrentTemplateObject новый объект
            return pCurrentTemplateObject->Clone();
        }
   }

   throw std::logic_error("unavailable level");
}

QVector<QString> LevelsFactory::GetLevelsName()
{
    //бежим по каждому из прототипов (эталонных объектов)
    //и собираем имена
    QVector<QString> levelsNames;
    for( auto& lvl : GetAvailableLevels())
        levelsNames.push_back(lvl->GetName());

    return levelsNames;
}

std::vector<std::unique_ptr<DifficultLvlBase>>& LevelsFactory::GetAvailableLevels()
{
    static std::vector<std::unique_ptr<DifficultLvlBase>> availableLevels;
    //создаю эталонные объекты - прототипы, из которых в дальнейшем
    //конструерую объекты уровней через clone
    if(availableLevels.empty())
    {
        availableLevels.push_back(std::make_unique<DifficultLvl_4_4>());
        availableLevels.push_back(std::make_unique<DifficultLvl_9_9>());
        availableLevels.push_back(std::make_unique<DifficultLvl_16_16>());
    }

    return availableLevels;
}

void SudokuGame::Create(std::unique_ptr<DifficultLvlBase> pLevel)
{
    m_pLevel.reset();
    m_pLevel = std::move(pLevel);
    m_pLevel->CreateNewGame();
}

bool SudokuGame::IsAutoGeneratedItem(int nRow, int nCol) const
{

    Cell* pSelectedCell = nullptr;

    if(GetRequiredCell(nRow, nCol, pSelectedCell))
        return pSelectedCell->IsAutoGenerated();

    return false;
}

bool SudokuGame::GetItemValue(int nRow, int nCol, QString &outValue) const
{
    Cell* pSelectedCell = nullptr;

    if(GetRequiredCell(nRow, nCol, pSelectedCell))
    {
        outValue = pSelectedCell->GetValue();
        return true;
    }

    return false;
}

void SudokuGame::SetItemValue(int nRow, int nCol, const QString &value)
{
    Cell* pSelectedCell = nullptr;

    if(GetRequiredCell(nRow, nCol, pSelectedCell))
        pSelectedCell->SetValue(value);
}

bool SudokuGame::GetRequiredCell(int nRow, int nCol, Cell *&outCell) const
{
    Cell proxyCell(nRow, nCol);

    for(int n = 0; n < m_pLevel->GetTable().size(); ++n)
    {
        if(m_pLevel->GetTable()[n] == proxyCell)
        {
            outCell = &m_pLevel->GetTable()[n];
            return true;
        }
    }

    return false;
}
