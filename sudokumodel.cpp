#include "sudokumodel.h"
#include <QMessageBox>
#include <QSize>
#include <algorithm>

SudokuModel::SudokuModel() : m_activeLvl(LevelsFactory::CreateDefault())
{

}

int SudokuModel::rowCount(const QModelIndex &parent) const
{
    return getDifficultLvl().GetRowsCnt();
}

int SudokuModel::columnCount(const QModelIndex &parent) const
{
    return getDifficultLvl().GetColumnsCnt();
}

QVariant SudokuModel::data(const QModelIndex &index, int role) const
{
//Qt::BackgroundColorRole
    if (Qt::TextAlignmentRole == role)
           return Qt::AlignCenter;

    if(!index.isValid())
         return QVariant();

    int nRow = index.row();
    int nCol = index.column();

   if (Qt::BackgroundColorRole == role &&
       m_activeLvl.IsAutoGeneratedItem(nRow, nCol))
        return  QColor(188, 196, 230, 127);

    if(Qt::EditRole != role && Qt::DisplayRole !=role)
        return QVariant();



    uint resValue = 0;
    if(!getDifficultLvl().GetItemValue(nRow, nCol,resValue))
        return QVariant();


    return resValue;
}

bool SudokuModel::setData(const QModelIndex &index, const QVariant &value, int role)
{

    if(!index.isValid() || role != Qt::EditRole)
        return false;

    int nRow = index.row();
    int nCol= index.column();

    if(m_activeLvl.IsAutoGeneratedItem(nRow, nCol))
        return false;

    bool isConversionOk = false;
    unsigned int nSettingValue = value.toUInt(&isConversionOk);
    if(!isConversionOk)
        return false;

    getDifficultLvl().SetItemValue(nRow, nCol, nSettingValue);


    emit dataChanged(index,index);

    return true;
}

SudokuLevel &SudokuModel::getDifficultLvl()
{
    return m_activeLvl;
}

const SudokuLevel &SudokuModel::getDifficultLvl() const
{
    return m_activeLvl;
}

void SudokuModel::SetDifficult(const QString& strDifficultName)
{
    try {
        m_activeLvl = LevelsFactory::Create(strDifficultName);
    } catch (const std::exception& ex) {
        QMessageBox::critical(nullptr,"Ошибка", "Ошибка установки уровня");
    }
}




QVector<SudokuLevel> LevelsFactory::m_availableLevels =
{
    SudokuLevel("4x4",4),
    SudokuLevel("9x9",9),
    SudokuLevel("16x16",16)
};;

SudokuLevel LevelsFactory::CreateDefault(){return m_availableLevels.front();}

SudokuLevel LevelsFactory::Create(const QString &strDifficultName)
{
    for(int nLvl = 0; nLvl < m_availableLevels.size(); ++nLvl)
    {
        if(m_availableLevels[nLvl] == strDifficultName)
            return m_availableLevels[nLvl];

    }

   throw std::logic_error("unavailable level");
}

QVector<QString> LevelsFactory::GetLevelsName()
{
    QVector<QString> levelsNames;
    for(const SudokuLevel& lvl : m_availableLevels)
        levelsNames.push_back(lvl.GetName());

    return levelsNames;
}
