#include "sudokumodel.h"
#include <QMessageBox>
#include <QSize>
#include <algorithm>



//базовый класс вариантов генерации сетки
class MixingVariantBase
{
public:
    virtual void Invoke(DifficultLvlBase* pCurrentLvl) = 0;
    virtual ~MixingVariantBase(){}
};

//Транспонирование всей таблицы — столбцы становятся строками и наоборот (transposing)
class TranspositionVariant : public MixingVariantBase
{
public:
    void Invoke(DifficultLvlBase* pCurrentLvl) override
    {
        GameTable& gametable = pCurrentLvl->GetTable();

        for(int row = 0; row < pCurrentLvl->GetRowsCnt(); ++row)
        {
            for(int col = row; col < pCurrentLvl->GetColumnsCnt(); ++col)
            {

                Cell* pFirstCell = gametable.getCell(row, col);
                Cell* pSecondCell = gametable.getCell(col, row);

                if(pFirstCell && pSecondCell)
                {
                    QString strTmp = pFirstCell->GetValue();
                    pFirstCell->SetValue(pSecondCell->GetValue());
                    pSecondCell->SetValue(strTmp);
                }

            }
        }
    }
};

//Обмен двух строк в пределах одного района
class SwapRowsSmallVariant : public MixingVariantBase
{
  public:
    void Invoke(DifficultLvlBase* pCurrentLvl) override
    {
        GameTable& gametable = pCurrentLvl->GetTable();
        int nCellCounting = pCurrentLvl->GetCellCountingRowAndColumnForRegion();
       /* for(int row = 0; row < pCurrentLvl->GetRowsCnt(); ++row)
        {
            for(int col = 0; col < pCurrentLvl->GetColumnsCnt(); ++col)
            {

                Cell* pFirstCell = gametable.getCell(row, col);
                Cell* pSecondCell = gametable.getCell(col, row);

                if(pFirstCell && pSecondCell)
                {
                    QString strTmp = pFirstCell->GetValue();
                    pFirstCell->SetValue(pSecondCell->GetValue());
                    pSecondCell->SetValue(strTmp);
                }

            }
        }*/

    }
};


SudokuModel::SudokuModel()
{
m_Game.Create(LevelsFactory::Create("4 x 4"));
}

int SudokuModel::rowCount(const QModelIndex &parent) const
{
    return  m_Game.GetLevel()->GetRowsCnt();
}

int SudokuModel::columnCount(const QModelIndex &parent) const
{
    return m_Game.GetLevel()->GetColumnsCnt();
}

QVariant SudokuModel::data(const QModelIndex &index, int role) const
{
//Qt::BackgroundColorRole
    if (Qt::TextAlignmentRole == role)
           return Qt::AlignCenter;

    if(!index.isValid())
         return QVariant();

    int nRow = index.row();
    int nCol = index.column();

   if (Qt::BackgroundColorRole == role &&
       m_Game.IsAutoGeneratedItem(nRow, nCol))
        return  QColor(188, 196, 230, 127);

    if(Qt::EditRole != role && Qt::DisplayRole !=role)
        return QVariant();



    QString resValue;
    if(!m_Game.GetItemValue(nRow, nCol,resValue))
        return QVariant();


    return resValue;
}

bool SudokuModel::setData(const QModelIndex &index, const QVariant &value, int role)
{

    if(!index.isValid() || role != Qt::EditRole)
        return false;

    int nRow = index.row();
    int nCol= index.column();

    if(m_Game.IsAutoGeneratedItem(nRow, nCol))
        return false;


    QString settingValue = value.toString();
    m_Game.SetItemValue(nRow, nCol, settingValue);

    emit dataChanged(index,index);

    return true;
}

int SudokuModel::GetDifficultValue() const{return m_Game.GetLevel()->GetDifficultValue();}


void SudokuModel::SetDifficult(const QString& strDifficultName)
{
    //от пункта меню
    try {
        m_Game.Create(LevelsFactory::Create(strDifficultName));
    } catch (const std::exception& ex) {
        QMessageBox::critical(nullptr,"Ошибка", "Ошибка установки уровня");
    }
}



std::unique_ptr<DifficultLvlBase> LevelsFactory::Create(const QString &strDifficultName)
{
    for(size_t nLvl = 0; nLvl < GetAvailableLevels().size(); ++nLvl)
    {
        //беру эталонный объект, из которого хочу создать копию
        const std::unique_ptr<DifficultLvlBase>& pCurrentTemplateObject = GetAvailableLevels().at(nLvl);
        if(pCurrentTemplateObject->GetName() == strDifficultName)
        {
             //изготавливаю из прототипа pCurrentTemplateObject новый объект
            return pCurrentTemplateObject->Clone();
        }
   }

   throw std::logic_error("unavailable level");
}

QVector<QString> LevelsFactory::GetLevelsName()
{
    //бежим по каждому из прототипов (эталонных объектов)
    //и собираем имена
    QVector<QString> levelsNames;
    for( auto& lvl : GetAvailableLevels())
        levelsNames.push_back(lvl->GetName());

    return levelsNames;
}

std::vector<std::unique_ptr<DifficultLvlBase>>& LevelsFactory::GetAvailableLevels()
{
    static std::vector<std::unique_ptr<DifficultLvlBase>> availableLevels;
    //создаю эталонные объекты - прототипы, из которых в дальнейшем
    //конструерую объекты уровней через clone()
    if(availableLevels.empty())
    {
        availableLevels.push_back(std::make_unique<DifficultLvl_4_4>());
        availableLevels.push_back(std::make_unique<DifficultLvl_9_9>());
        availableLevels.push_back(std::make_unique<DifficultLvl_16_16>());
    }

    return availableLevels;
}

void SudokuGame::Create(std::unique_ptr<DifficultLvlBase> pLevel)
{
    m_pLevel.reset();
    m_pLevel = std::move(pLevel);
    LevelBuilder levelBuilder;
    m_pLevel->CreateNewGame(&levelBuilder);
}

bool SudokuGame::IsAutoGeneratedItem(int nRow, int nCol) const
{
    Cell* pSelectedCell = m_pLevel->GetTable().getCell(nRow, nCol);

    if(pSelectedCell)
        return pSelectedCell->IsAutoGenerated();

    return false;
}

bool SudokuGame::GetItemValue(int nRow, int nCol, QString &outValue) const
{
    Cell* pSelectedCell = m_pLevel->GetTable().getCell(nRow, nCol);

    if(pSelectedCell)
    {
        outValue = pSelectedCell->GetValue();
        return true;
    }

    return false;
}

void SudokuGame::SetItemValue(int nRow, int nCol, const QString &value)
{
    Cell* pSelectedCell = m_pLevel->GetTable().getCell(nRow,nCol);

    if(pSelectedCell)
        pSelectedCell->SetValue(value);
}



void LevelBuilder::MakeLevel(DifficultLvlBase *pCurrentLvl)
{
    m_pCurrentLvl = pCurrentLvl;
    //m_currentLvl->m_table;

    //Шаг 0. Заполнение буфера от 1 до максимального числа
    // GreateNumbers();
    //Шаг 1. Взять за основу базовую сетку
    CreateBaseGrid();

    //Шаг 2. Перетасовать сетку
    TranspositionVariant().Invoke(m_pCurrentLvl);
}

void LevelBuilder::CreateBaseGrid()
{
    int nCellCounting = m_pCurrentLvl->GetCellCountingRowAndColumnForRegion();


    GameTable& gametable = m_pCurrentLvl->GetTable();

    for(int row = 0; row < m_pCurrentLvl->GetRowsCnt(); ++row)
    {
        for(int col = 0; col < m_pCurrentLvl->GetColumnsCnt(); ++col)
        {
            Cell* pCell = gametable.getCell(row, col);
            if(!pCell)
                continue;

            //волшебная формула генерации сетки
            int value = (row*nCellCounting + row/nCellCounting + col) % (nCellCounting*nCellCounting) + 1;
            pCell->SetValue(QString::number(value));
        }
    }
}
