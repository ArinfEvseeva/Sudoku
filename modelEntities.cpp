#include "modelEntities.h"


SudokuLevel::SudokuLevel(const QString &name, int difficultValue) : m_name{name},
    m_difficultValue{difficultValue},
    m_columnsCnt{difficultValue},
    m_rowsCnt{difficultValue}
{
    Init();
}

bool SudokuLevel::IsAutoGeneratedItem(int nRow, int nCol) const
{
    Cell* pSelectedCell = nullptr;

    if(GetRequiredCell(nRow, nCol, pSelectedCell))
        return pSelectedCell->IsAutoGenerated();

    return false;
}

bool SudokuLevel::GetItemValue(int nRow, int nCol, uint &outValue) const
{

    Cell* pSelectedCell = nullptr;

    if(GetRequiredCell(nRow, nCol, pSelectedCell))
    {
        outValue = pSelectedCell->GetValue();
        return true;
    }

    return false;
}

void SudokuLevel::SetItemValue(int nRow, int nCol, const uint value)
{
    Cell* pSelectedCell = nullptr;

    if(GetRequiredCell(nRow, nCol, pSelectedCell))
        pSelectedCell->SetValue(value);
}

void SudokuLevel::Init()
{
    for(int nRow = 0; nRow < m_rowsCnt; ++ nRow)
    {
        for(int nCol = 0; nCol < m_columnsCnt; ++ nCol)
        {

            //Todo write generator
            Cell newCell(nRow, nCol,true);
            newCell.SetValue(0);
            m_table.push_back(newCell);
        }
    }
}

bool SudokuLevel::GetRequiredCell(int nRow, int nCol, Cell*& outCell) const
{
    Cell proxyCell(nRow, nCol);
    for(int n = 0; n < m_table.size(); ++n)
    {
        if(m_table[n] == proxyCell)
        {
            outCell = &m_table[n];
            return true;
        }
    }

    return false;
}
